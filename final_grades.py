from grades import load_grades
import os
import json
import pandas as pd
import dateutil.parser
import numpy as np

''' === SETUP === '''
# Path to the Canvas roster (download Gradebook csv) for this class.
# :: This is used to determine who is still in the class.
PATH_TO_CANVAS_ROSTER = "data/roster/roster.csv"

# The calculated slip days for students, generated by slip_days.py.
PATH_TO_SLIP_DAYS_CSV = "data/slip_days.csv"

# Where the quizzes (exported GS analysis csv's) are stored.
# Quizzes must be in format: [month]-[day].csv
PATH_TO_QUIZ_DIR = 'data/quizzes'

# A JSON file with keys for particular quizzes (name of the quiz csv file),
# mapped to arrays of student IDs for the students exempt from taking that quiz.
# :: If you don't know what this is, set to None.
PATH_TO_QUIZ_EXCEPTIONS_JSON = "data/quiz_exceptions.json" # could be None

# Where the final exam CSVs are. Note that these are just GS "Export Grades" csvs;
# they aren't loaded by the fine-grained question loader in grades.py.
PATH_TO_FINALS = "data/final"

# Whether to export grade reports to pdfs
PRINT_STUDENT_REPORTS = False
DIR_FOR_GRADE_REPORT_PDFS = 'data/grade_pdfs'

# Map rubric files to directories containing all assignment eval sheets from GS.
# *This assumes the json rubrics are in /rubrics and the assignment folders are in the /data folder.*
# **Assumes you also have SCORE SHEETS in each assignment directory! These are required for Lateness calculation!!**
rubric_data_map = {
    'checkin': 'checkin',
    'dw1': 'dw1',
    'dw2': 'dw2',
    'dw3': 'dw3',
    'dw4': 'dw4', # This should be optional
    'dw5': 'dw5',
    'mp1': 'mp1',
    'mp2': 'mp2',
    'mp3_indiv': 'mp3/indiv',
    'mp3_group': 'mp3/group', # TODO: Don't take off slip days for both!
    'mp4': 'mp4'
}

# Grade mapping
letter_grade_map = {
    97.5: "A+",
    93.5: "A",
    90: "A-",
    87.5: "B+",
    83.5: "B",
    80: "B-",
    77.5: "C+",
    73.5: "C",
    70: "C-",
    60: "D",
    0: "F"
}
''' === END SETUP === '''

''' === HELPER CODE === '''
def grade_mapping(final_grade):
    for key, letter in letter_grade_map.items():
        if final_grade >= key:
            return letter
# Wrapper class for students
class Student:
    def __init__(self, email, sid, name):
        self.email = email
        self.sid = sid
        self.name = name
        self.grades = dict()

    # Return the students' grade for the given assignment.
    # :: If the grade's missing, count as a zero.
    def grade_for(self, assn):
        return self.grades[assn] if assn in self.grades else 0

    def set_grade(self, assn, score):
        self.grades[assn] = score

    def add_grade(self, assn, score):
        if assn in self.grades:
            self.grades[assn] += score
        else:
            self.grades[assn] = score
''' === END HELPER CODE === '''

''' === LOAD SLIP DAYS === '''
# "Each slip day beyond the 7 allowed for the course will result in a deduction of 1/2 point from your final grade"
slip_days = dict()
def read_slips(row):
    slip_days[row['Email'].strip()] = int(row['Slip Days Remaining'])
# the final used slip days, to factor into the final grade
df = pd.read_csv(PATH_TO_SLIP_DAYS_CSV)
df.apply(read_slips, axis=1)

''' === LOAD STUDENT ROSTER === '''
# The full list of students in the class, a dict of Student objs indexed by sid
roster = dict()
df = pd.read_csv(PATH_TO_CANVAS_ROSTER)
df.drop(index=[1, 2, len(df)-1], inplace=True)
df.dropna(subset=['SIS User ID'], inplace=True)
def read_student(row):
    sid = int(row['SIS User ID'])
    email = row['SIS Login ID']+"@cornell.edu"
    name = row['Student']
    roster[sid] = Student(email, sid, name)
    roster[sid].set_grade('extra_credit_1', float(row['Active Learning Initiative Survey (221004)']))
    # roster[sid].set_grade('extra_credit_2', float(row['ALI Survey 2 (245236)'])) # EDIT when you have it
df.apply(read_student, axis=1)

''' === LOAD FINAL EXAM GRADES === '''
def read_final_exam(row):
    sid = int(row['SID'])
    roster[sid].set_grade('final_exam', int(row['Total Score']))
final_csvs = [entry.path for entry in os.scandir(PATH_TO_FINALS) if entry.path.endswith(".csv")]
for csv in final_csvs:
    df = pd.read_csv(csv)
    df = df[df['Status']=='Graded'] # Consider only exams marked Graded
    df.apply(read_final_exam, axis=1) # Read exam score into the dictionary of Students

''' === LOAD QUIZ GRADES === '''
# :: Quiz names should be in format: [Month#]-[Day#]
quiz_exceptions = {}
if PATH_TO_QUIZ_EXCEPTIONS_JSON:
    with open(PATH_TO_QUIZ_EXCEPTIONS_JSON) as f:
      quiz_exceptions = json.load(f)
quizzes = []
for entry in os.scandir(PATH_TO_QUIZ_DIR):
    if not entry.path.endswith(".csv"): continue

    # Extract file name
    filename = os.path.splitext(os.path.basename(entry.path))[0]
    assn_name = 'quiz-'+filename
    quizzes.append(assn_name)

    # Calculate the proper submission time for this quiz,
    # assuming csv files are named with the dates quizzes were due...
    month, day = filename.split('-')
    if len(day) == 1:
        day = '0'+day
    # Note that it SHOULD be 16:20 UTC to correspond to 12:20 EST, HOWEVER
    # for some reason Canvas is off by 1 hour (maybe daylight savings...?)
    # :: I give 1 minute grace period for quizzes
    if int(month) < 4 or (int(month) == 3 and int(day) < 14):
        proper_submission_time = dateutil.parser.parse('2021-0{}-{} 17:21:00 UTC'.format(month, day))
    else:
        proper_submission_time = dateutil.parser.parse('2021-0{}-{} 16:21:00 UTC'.format(month, day))

    # Special exception quizzes
    if int(month) == 3 and int(day) == 25:
        proper_submission_time = dateutil.parser.parse('2021-0{}-{} 03:59:00 UTC'.format(month, int(day)+1))

    def calc_quiz_grade(row):
        sid = row['sis_id']
        if sid not in roster: return # if person dropped the class, skip
        if filename in quiz_exceptions and \
            sid in quiz_exceptions[filename]: return # people exempt from specific quizzes
        datestring = row['submitted']
        time_submitted = dateutil.parser.parse(datestring)
        is_late = time_submitted > proper_submission_time # if it's late
        score = 0.5 if is_late else 1
        roster[sid].set_grade(assn_name, score)

    # Read quiz data
    df = pd.read_csv(entry.path)

    # Keep only the very *first* attempt (we only care about lateness, not score)
    # :: https://stackoverflow.com/questions/15705630/get-the-rows-which-have-the-max-value-in-groups-using-groupby
    df.sort_values('attempt', ascending=True).drop_duplicates(['sis_id'], inplace=True)

    # For each student's attempt, calculate lateness + final score:
    df.apply(calc_quiz_grade, axis=1)

''' === LOAD ASSIGNMENT GRADES === '''
# The max scores/points for each assignment
max_score = dict()
max_score['mp3'] = 100

# For each assignment, extract grades and set in that Student obj
# :: NOTE: We have to keep track of slip days *chronologically* w/ assignments
# :: in order to decide when to take off for lateness.
emails_to_names = {}
for rubric_name, dir_name in rubric_data_map.items():
    rubric_path, data_path = os.path.join('rubrics', rubric_name+'.json'), os.path.join('data', dir_name)
    if not (os.path.exists(rubric_path) and os.path.exists(data_path)):
        print('Skipping assignment "{}": Could not find rubric or data.'.format(rubric_path))
        continue
    grades, rubric, questions = load_grades(rubric_path, data_path, only_submitted=True)
    max_score[rubric_name] = rubric['maxScore']
    for g in grades:
        sid = g['sid']
        if sid not in roster: continue # this student dropped

        # Set/add grade for this assignment to the student's score:
        score = g['total_score']
        roster[sid].add_grade(rubric_name, score)

        # Add any extra credit
        if rubric_name == 'dw1' and roster[sid].grade_for('extra_credit_1') > 0:
            roster[sid].add_grade(rubric_name, 1)
        if rubric_name == 'dw5' and roster[sid].grade_for('extra_credit_2') > 0:
            roster[sid].add_grade(rubric_name, 3)


''' === THE FINAL COUNTDOWN TALLY === '''
# Now we should have all grades loaded. For each student, we need to tally grades
print('{:<10s}\t{}\t{}\t{}\t{}\t{}\t{}'.format('Name', 'SID', 'DW', 'MP', 'Quiz', 'Slip mod', 'Total'))
final_grades = []
for sid, student in roster.items():

    # Design workbook tally -- regular
    dropped_dw4 = False
    if student.grade_for('dw4') > 0:
        dw_total_score = sum([max_score[a] for a in ['checkin', 'dw1', 'dw2', 'dw3', 'dw4', 'dw5']])
        dw_percent = sum([student.grade_for(a) for a in ['checkin', 'dw1', 'dw2', 'dw3', 'dw4', 'dw5']]) / dw_total_score
    else:
        dropped_dw4 = True
        dw_total_score = sum([max_score[a] for a in ['checkin', 'dw1', 'dw2', 'dw3', 'dw5']])
        dw_percent = sum([student.grade_for(a) for a in ['checkin', 'dw1', 'dw2', 'dw3', 'dw5']]) / dw_total_score
    # Design workbook tally -- where dw1 is downweighted
    if student.grade_for('dw4') > 0:
        dw_total_score = sum([max_score[a] for a in ['checkin', 'dw2', 'dw3', 'dw4', 'dw5']]) + 60
        dw_percent_2 = (sum([student.grade_for(a) for a in ['checkin', 'dw2', 'dw3', 'dw4', 'dw5']]) + student.grade_for('dw1')*3/5.0) / dw_total_score
    else:
        dropped_dw4 = True
        dw_total_score = sum([max_score[a] for a in ['checkin', 'dw2', 'dw3', 'dw5']]) + 60
        dw_percent_2 = (sum([student.grade_for(a) for a in ['checkin', 'dw2', 'dw3', 'dw5']]) + student.grade_for('dw1')*3/5.0) / dw_total_score
    # Take largest for final DW grade:
    dw_final_perc = max(dw_percent, dw_percent_2)

    dw_scores = ''
    for a in ['checkin', 'dw1', 'dw2', 'dw3', 'dw4', 'dw5']:
        if a == 'dw4' and dropped_dw4:
            dw_scores += "(dropped: {:.1f}) ".format(student.grade_for(a) / max_score[a] * 100)
        else:
            dw_scores += "{:.1f} ".format(student.grade_for(a) / max_score[a] * 100)

    # Miniprojects --all weighted equally
    mp_final_perc = 0
    mp_scores = ''
    student.set_grade('mp3', student.grade_for('mp3_indiv') + student.grade_for('mp3_group'))
    for a in ['mp1', 'mp2', 'mp3', 'mp4']:
        perc = student.grade_for(a) / max_score[a]
        mp_final_perc += perc
    mp_final_perc /= 4.0

    # Tally total quiz score (percentage)
    quiz_final_perc = sum([student.grade_for(q) for q in quizzes]) / len(quizzes)

    # Extract final exam score (if taken)
    exam_final_perc = student.grade_for('final_exam') / 100.0

    # Tally any slip days
    slip_mod = 0
    if student.email in slip_days:
        slips = slip_days[student.email]
        if slips < 0:
            slip_mod = -0.5 * slips

    '''(Sample calculation from last year:
    Design responses: 93.166664 DR: 95.0 89.5 (dropped: 76.5) 90.0 95.0 97.5 92.0
    Miniprojects: 91.52 MP:97.3 90.0 97.0 80.9 92.4
    Final exam: 95.8 (Exam grade: 94.8; Extra credit: 1.0)
    Participation: 100.0")'''

    # Final percentage grade
    if exam_final_perc == 0:
        final_grade = (40*dw_final_perc + 40*mp_final_perc + 5*quiz_final_perc) / 85.0 * 100 - slip_mod
    else:
        final_grade = (40*dw_final_perc + 40*mp_final_perc + 5*quiz_final_perc + 15*exam_final_perc) - slip_mod

    # Calculate final letter grade
    final_letter_grade = grade_mapping(final_grade)

    final_grades.append((student.name, student.email, student.sid, dw_final_perc*100, dw_scores, mp_final_perc*100, mp_scores, quiz_final_perc*100, exam_final_perc*100, -slip_mod, final_grade, final_letter_grade))

''' === PRETTY PRINT FINAL GRADE TABLE === '''
final_grades.sort(key=lambda x: x[10]) # sort by final grade
for g in final_grades:
    print('{:>20s}\t{:.2f}\t{:.2f}\t{:.2f}\t{:.2f}\t{:.2f}\t{:.2f}\t{}'.format(g[0], g[3], g[5], g[7], g[8], g[9], g[10], g[11]))

''' === PRETTY PRINT FINAL GRADE DISTRIBUTION === '''
scores = [g[10] for g in final_grades]
frequency, bins = np.histogram(scores, bins=20, range=[0, 100]) # Compute frequency and bins
for b, f in zip(bins[1:], frequency):
    print(round(b, 1), ' '.join(np.repeat('*', f)))

''' === EXPORT FINAL GRADE TABLE === '''
df_slips = pd.DataFrame(final_grades, columns=["Name", "Email", "SID", "DW Final", "DWs: Checkin 1 2 3 (4) 5", "MP Final", "MPs: 1 2 [3_indiv 3_group] 4", "Quizzes", "Final Exam", "Slip Penalty (points docked from final percentage)", "Final Perc", "Calc Letter Grade"])
df_slips.to_csv("final_grades.csv", index=False)

''' ------------------------------------------------------ '''
''' === EXPORT STUDENT GRADE REPORTS (PDFs; optional) === '''
if PRINT_STUDENT_REPORTS == False:
    exit(0)
assn_name_map = {
    'checkin': 'Design Workbook Check-in',
    'dw1': 'Design Workbook 1',
    'mp1': 'Miniproject 1',
    'dw2': 'Design Workbook 2',
    'mp2': 'Miniproject 2',
    'dw3': 'Design Workbook 3',
    'mp3_indiv': 'Miniproject 3 - Indiv',
    'mp3_group': 'Miniproject 3 - Group', # TODO: Don't take off slip days for both!
    'dw4': 'Design Workbook 4', # This should be optional
    'dw5': 'Design Workbook 5',
    'mp4': 'Miniproject 4',
    'quiz': 'Quizzes (completion rate)'
}
for sid, student in roster.items():
    report = []
    graded_assns = dict()
    ungraded_assns = dict()

    # Tally indiv grades
    for assn_name in rubric_data_map.keys():
        perc_score = student.grade_for(assn_name) / max_score[assn_name]
        if perc_score > 0:
            graded_assns[assn_name] = perc_score
        else:
            ungraded_assns[assn_name] = perc_score

    # Tally total quiz score (percentage)
    graded_assns['quiz'] = sum([student.grade_for(q) for q in quizzes]) / len(quizzes)

    report.append('Name: ' + student.name)
    report.append('ID: ' + str(sid))
    report.append('Graded assignments:')
    for assn_name, perc_score in graded_assns.items():
        report.append('   {}:\t{:.2f}%'.format(assn_name_map[assn_name], 100*perc_score))
    report.append('Assignments with no grades:')
    for assn_name, _ in ungraded_assns.items():
        report.append('   {}'.format(assn_name_map[assn_name]))
    report.append("(In some cases a missing grade means we're yet to grade it, other cases")
    report.append("there is no submission. The algorithm can't determine which is which")
    report.append("so you should interpret what a missing grade means based")
    report.append("on your particular circumstance.")
    report.append("Also note that DW5&6 will come in as a grade.)")
    if student.email in slip_days:
        report.append('Slip days remaining: {}'.format(slip_days[student.email]))
        report.append('  If you have negative slip days, the course policy is repeated below:')
        report.append('  "Each slip day beyond the 7 allowed for the course will result in')
        report.append('   a deduction of 1/2 point from your final grade."')
    else:
        print("Error: Could not find slip days for student", student.name, student.email)
    student.report = report

# Export student grades to PDF files
from fpdf import FPDF
for sid, student in roster.items():
    pdf = FPDF()
    pdf.add_page()
    # set style and size of font that you want in the pdf
    # pdf.add_font('HomemadeApple', '', 'HomemadeApple.ttf', uni=True)
    pdf.set_font("Arial", size = 15)

    pdf.set_line_width(0.7)
    pdf.line(28, 18, 100, 18)
    pdf.line(20, 28, 100, 28)

    # insert the texts in pdf
    for i, txt in enumerate(student.report):
        # if i == 2:
        #     pdf.set_font("Arial", size = 15)
        pdf.cell(200, 10, txt = txt, ln = 1, align = 'L')

    # save the pdf with name .pdf
    last, first = student.name.split(', ')
    if len(first) > 1:
        first = first.split(' ')[0]
    pdf.output(DIR_FOR_GRADE_REPORT_PDFS+"/{}_{}.pdf".format(first, last))
